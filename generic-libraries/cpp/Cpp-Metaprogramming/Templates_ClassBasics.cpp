#include <iostream>
// Usually one would only include the .h file so that the actual code can be linked separately
// and does not weigh down the other artifact, but in this case the compiler needs to have access to the
// code it is generating. this has negative impacts on libraries, especially commercial ones, which might not
// wnat to share their code
#include "Stack.cpp"
using namespace std;


//General notes:
// Each binary object has their own instances of generic classes and methods, as a result the same code might
// exist twice in binary form
//
// Class members are instantiated lazyly, as a result methods that are not needed are not generated by the
// compiler
//
// Its possible to have different parameters for class and methods, in which case both paramters need to
// be supplied when implementing such a method, making the code rather unreadable
// template <typename T> template <typename S> void Stack<T>::doSomething(S value)

int main(int argc, char **argv) {

	//its possible to define default values for template types
	Stack<> stack;
	stack.push(1);
	stack.push(2);

	cout << stack.pop() << "," << stack.pop() << endl;

	Stack<double> stack2;
	stack2.push(1.0);
	stack2.push(2.0);

	cout << stack2.pop() << "," << stack2.pop() << endl;

	//static variables exist per instance, so it is not possible to count the occurrences for the class
	//in total
	cout << StackNode<int>::getNodeCount() << "," << StackNode<double>::getNodeCount() << endl;
}
